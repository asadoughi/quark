# Copyright 2014 Openstack Foundation
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
#   Original script found here:
#   https://github.com/asadoughi/quark/blob/oneoff_update/bin/oneoff
#

from datetime import timedelta
from oslo.config import cfg

from neutron.common import config
from neutron.db import api as neutron_db_api
from oslo.utils import timeutils
from quark.db import models

from sqlalchemy import or_, func

import argparse
import netaddr
import smtplib
import socket
import sys


def main():
    neutron_db_api.get_engine()
    do(neutron_db_api.get_session())


def _rackspace_filter(query):
    private = '11111111-1111-1111-1111-111111111111'
    public = '00000000-0000-0000-0000-000000000000'
    query = query.filter(or_(models.Subnet.network_id == private,
                             models.Subnet.network_id == public))
    return query


def send_email_to_neutron_list(message):
    hostname = socket.getfqdn()
    fromaddr = ("%s@localhost.com" % hostname)
    #toaddr = 'neutron@lists.rackspace.com'
    toaddr = 'jason.meridth@rackspace.com'
    msg = ("Running of Neutron fill_in_ip_address_gaps_in_subnets"
           " script.\n"
           "Results:\n"
           "%s\n\n"
           "How to run the script so the IPs are inserted:\n"
           "Get onto the host: %s\n"
           "Run the following:\n"
           "/opt/rackstack/neutron/current/neutron/bin/python"
           " /opt/rackstack/neutron/current/neutron/bin/"
           "fill_in_ip_address_gaps_in_subnets --confile-file"
           " /etc/neutron/neutron.conf "
           % (message, hostname))
    server = smtplib.SMTP('localhost')
    server.sendmail(fromaddr, toaddr, msg)
    server.quit()
    print("Email sent to %s" % toaddr)


def do(session):
    # 1. get subnets with next_auto_assign_ip < first_ip or next_auto_assign_ip
    #    > last_ip along with the number of IPs they have in the DB
    with session.begin():
        query = session.query(
            models.Subnet,
            func.count(models.IPAddress.id).label("count"))
        query = query.filter(models.Subnet.id == models.IPAddress.subnet_id)
        query = query.filter(models.Subnet.ip_version == 4)
        query = query.filter(or_(models.Subnet.do_not_use is None,
                                 models.Subnet.do_not_use == 0))
        query = _rackspace_filter(query)
        query = query.group_by(models.Subnet.id)
        query = query.order_by(models.Subnet.segment_id)
        subnets = query.all()

    # 2. figure out which subnets to update
    subnets_to_update = []
    for subnet, count in subnets:
        with session.begin():
            ipp = models.IPPolicy.get_ip_policy_cidrs(subnet)
            res = netaddr.IPSet(netaddr.IPNetwork(subnet._cidr)) - ipp
            if count != res.size:
                subnets_to_update.append(subnet)

    # 3. figure out which IPs need to be put into the databse to fille
    #    the gaps
    total_ips_to_insert = 0
    message = ''
    for subnet in subnets_to_update:
        with session.begin():
            query = session.query(models.IPAddress.address)
            query = query.filter(subnet.id == models.IPAddress.subnet_id)

            def _map(addr):
                ip = netaddr.IPAddress(addr[0])
                return ip.ipv4()
            addrs = [_map(addr) for addr in query.all()]
            ipp = models.IPPolicy.get_ip_policy_cidrs(subnet)
            s = netaddr.IPNetwork(subnet.cidr)
            ips_to_insert = netaddr.IPSet(s) - ipp - netaddr.IPSet(addrs)
            total_ips_to_insert += ips_to_insert.size
            if ips_to_insert.size > 0:
                message += "\n"
                message += "=" * 50
                message += "\n"
                message += "SEGMENT ID/CELL: %s\n" % subnet.segment_id
                message += "Network ID: %s\n" % subnet.network_id
                message += "Subnet ID: %s\n" % subnet.id
                message += "Number of IPs to insert: %s" % ips_to_insert.size
            if not args.dryrun:
                for ip in ips_to_insert:
                    new_ip = dict(subnet_id=subnet.id,
                                  network_id=subnet.network.id,
                                  version=subnet.ip_version,
                                  address=ip)
                    ip_address = models.IPAddress()
                    ip_address.update(new_ip)
                    ip_address["address"] = int(ip.ipv6())
                    ip_address["address_readable"] = str(ip)
                    ip_address["_deallocated"] = 1
                    window = timedelta(seconds=cfg.CONF.QUARK.ipam_reuse_after)
                    ip_address["deallocated_at"] = timeutils.utcnow() - window
                    ip_address["created_at"] = timeutils.utcnow()
                    session.add(ip_address)

                subnet.update(dict(next_auto_assign_ip=-1))
                session.add(subnet)

    message += "\n\nTotal IPs to insert: %s\n" % total_ips_to_insert
    print(message)
    if total_ips_to_insert > 0 and args.email:
        send_email_to_neutron_list(message)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='fill_in_ip_address_gaps_in_subnets')
    parser.add_argument('--config-file', default=None,
                        help='Specify a config file to use')
    parser.add_argument('--dryrun', action='store_true',
                        help='Do dry run.  No changes to database.')
    parser.add_argument('--email', action='store_true',
                        help='Send email to neutron@rackspace.com')

    args = parser.parse_args()

    if not args.config_file:
        sys.exit("ERROR: Unable to find configuration file via the default"
                 " search paths (~/.neutron/, ~/, /etc/neutron/, /etc/) and"
                 " the '--config' option!")
    else:
        config.init(['--config-file', args.config_file])
    main()
